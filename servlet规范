servletè§„èŒƒ

1 servlet 3.1è§„èŒƒ

1.1 What is servlet

    A servlet is a JavaTM technology-based Web component, managed by a container, that generates dynamic content. 

From servlet 3.1

1.2 History



From wiki

1.3 Servlet Life Cycle

- Loading and Instantiation
  When the servlet engine is started, needed servlet classes must be located by the
servlet container(WEB-INF/lib)
- Initialization
      The container initializes the servlet instance by calling the init method of the Servlet interface with a unique (per servlet declaration) object implementing the ServletConfig interface

ï¼ˆServletConfig used by Servlet Containerï¼‰

- Request Handling
  After a servlet is properly initialized, the servlet container may use it to handle client
requests. 
- End of Service

1.4 Servlet ç»§æ‰¿ç»“æ„



1.5 ServletContext

    	The ServletContext interface defines a servletâ€™s view of the Web application within which the servlet is running.  (web.xml) The Container Provider is responsible for providing an implementation of the ServletContext interface in the servlet container.

    InitParameter
    config 
    	-Filter
    	-Listenr
    	-Servlet
    Attribute
    Resource
    ...

see : ApplicationContextã€ApplicationContextFacade (tomcat)

1.6 Request 

HttpServletRequest

- HTTP Protocol Parameters
  â–  getParameter
  â–  getParameterNames 
  â–  getParameterValues 
  â–  getParameterMap
- File upload 
  content-type : multipart/form-data 
- Attributes 
- Headers
- Request Path Elements
  requestURI = contextPath + servletPath + pathInfo
- Path Translation Methods
  â–  ServletContext.getRealPath  
  â–  HttpServletRequest.getPathTranslated
- Non Blocking IO
  Non-blocking IO only works with async request processing in Servlets and Filters
- Cookies
- SSL
- Internationalization
  Accept-Language : zh-cn
- â–  getLocale
â–  getLocales
- Request data encoding 
  The default encoding of a request the container uses to create the request reader and parse POST data must be â€œISO-8859-1â€ if none has been specified by the client request. 
- Lifetime of the Request Object 
  Each request object is valid only within the scope of a servletâ€™s service method, or within the scope of a filterâ€™s doFilter method, unless the asynchronous processing is enabled for the component and the startAsync method is invoked on the request object. 

1.7 Response



1.8 Filter

 	what is Filter? 

    A filter is a reusable piece of code that can transform the content of HTTP requests,

responses, and header information.

    org.springframework.web.servlet.HandlerInterceptor

1.9 Lifecycle Events

    Event
    	-Servlet
    	-Session
    	-Request
    EventListener
    	-Servlet
    	-Session
    	-Request

Example : ServletContextListener

    public class ContextLoaderListener implements ServletContextListener {
        private ContextLoader contextLoader;
    
        public ContextLoaderListener() {
        }
    
        public void contextInitialized(ServletContextEvent event) {
            this.contextLoader = this.createContextLoader();
            this.contextLoader.initWebApplicationContext(event.getServletContext());
        }
    
        protected ContextLoader createContextLoader() {
            return new ContextLoader();
        }
    
        public ContextLoader getContextLoader() {
            return this.contextLoader;
        }
    
        public void contextDestroyed(ServletContextEvent event) {
            if(this.contextLoader != null) {
                this.contextLoader.closeWebApplicationContext(event.getServletContext());
            }
    
        }
    }

1.10 Session



2  Servlet 

    Server + Applet çš„ç¼©å†™ï¼Œè¡¨ç¤ºä¸€ä¸ªæœåŠ¡å™¨åº”ç”¨

2.1 Servletæ¥å£ 

    package javax.servlet;
    import java.io.IOException;
    public interface Servlet {
        public void init(ServletConfig config) throws ServletException;
        
        public ServletConfig getServletConfig();
        
        public void service(ServletRequest req, ServletResponse res)
       throws ServletException, IOException;
    
        public String getServletInfo();
        
        public void destroy();
        
    }

Load-on-startup ä¸ºè´Ÿçš„è¯ä¸ä¼šåœ¨å®¹å™¨å¯åŠ¨è°ƒç”¨

2.2 ServletConfigæ¥å£

    package javax.servlet;
    
    import java.util.Enumeration;
    
    /**
     * A servlet configuration object used by a servlet container
     * to pass information to a servlet during initialization. 
     */
     public interface ServletConfig {
        
        public String getServletName();
    
        public ServletContext getServletContext();
    
        public String getInitParameter(String name);
    
        public Enumeration<String> getInitParameterNames();
    
    }

å¦‚ä¸‹é…ç½®

    <!--web.xml-->
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app ...>
        <context-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>application-context.xml</param-value>
        </context-param>
    <servlet>
        <servlet-name>demoDispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.Dispatcher</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>demo-servlet.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    </web-app>

åœ¨Servletä¸­ å¯ä»¥åˆ†åˆ«é€šè¿‡å®ƒä»¬çš„getInitParameteræ–¹æ³•è·å–ï¼Œæ¯”å¦‚ï¼š

    String contextLocation = getServletConfig().getServletContext().getInitParameter(
        "contextConfigLocation");
    String servletLocation = getServletConfig().getInitParameter("contextConfigLocation");

2.3 GenerieServlet

    `Servlet`çš„é»˜è®¤å®ç°ï¼ŒåŒæ—¶å®ç°äº†`ServletConfig`æ¥å£ã€`Serializable`æ¥å£ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥è°ƒç”¨`ServletConfig`é‡Œé¢çš„æ–¹æ³•ã€‚è¯¦ç»†å¯å‚è€ƒå¦‚ä¸‹ç±»æ³¨é‡Šã€‚

    package javax.servlet;
    
    import java.io.IOException;
    import java.util.Enumeration;
    
    /**
     *
     * Defines a generic, protocol-independent
     * servlet. To write an HTTP servlet for use on the
     * Web, extend {@link javax.servlet.http.HttpServlet} instead.
     *
     * <p><code>GenericServlet</code> implements the <code>Servlet</code>
     * and <code>ServletConfig</code> interfaces. <code>GenericServlet</code>
     * may be directly extended by a servlet, although it's more common to extend
     * a protocol-specific subclass such as <code>HttpServlet</code>.
     *
     * <p><code>GenericServlet</code> makes writing servlets
     * easier. It provides simple versions of the lifecycle methods 
     * <code>init</code> and <code>destroy</code> and of the methods 
     * in the <code>ServletConfig</code> interface. <code>GenericServlet</code>
     * also implements the <code>log</code> method, declared in the
     * <code>ServletContext</code> interface. 
     *
     * <p>To write a generic servlet, you need only
     * override the abstract <code>service</code> method. 
     *
     */
    public abstract class GenericServlet 
        implements Servlet, ServletConfig, java.io.Serializable
    {
        private transient ServletConfig config;
    
        public GenericServlet() {}
    
        public void destroy() {}
        
        public String getInitParameter(String name) {
    		return getServletConfig().getInitParameter(name);
        }
        
        public Enumeration getInitParameterNames() {
    		return getServletConfig().getInitParameterNames();
        }   
        
        public ServletConfig getServletConfig() {
    		return config;
        }
        
        public ServletContext getServletContext() {
    		return getServletConfig().getServletContext();
        }
        
        public String getServletInfo() {
    		return "";
        }
    
        public void init(ServletConfig config) throws ServletException {
    		this.config = config;
    		this.init();
        }
    
        public void init() throws ServletException {
    
        }
        
        public void log(String msg) {
    		getServletContext().log(getServletName() + ": "+ msg);
        }
       
        public void log(String message, Throwable t) {
    		getServletContext().log(getServletName() + ": " + message, t);
        }
        
        public abstract void service(ServletRequest req, ServletResponse res)
    	throws ServletException, IOException;
        
        public String getServletName() {
            return config.getServletName();
        }
    }
    

é™„ï¼šä¸ºä»€ä¹ˆéœ€è¦å®ç° java.io.Serializable æ¥å£ï¼Ÿ

---

ç­”ï¼šåœ¨ Servlet 2.4 è§„èŒƒçš„ 7.7.2 Distributed Environments ç« èŠ‚ä¸­ï¼Œæœ‰ä¸€å¥è¿™æ ·çš„æè¿°ï¼š

    The distributed servlet container must support the mechanism necessary for
    
    migrating objects that implement Serializable.

    æŒ‰ç…§è§„èŒƒçš„è®¾è®¡ï¼ŒServlet æœ‰ä¸€ä¸ªé’åŒ–çš„ç‰¹æ€§ï¼Œç±»ä¼¼äº Servlet æŒä¹…åŒ–åˆ°æ–‡ä»¶ï¼Œç„¶åå½“å®¹å™¨ Crash å›å¤åï¼Œå¯ä»¥é‡æ–°æ¢å¤ä¿å­˜å‰çš„çŠ¶æ€ã€‚



2.4 HttpServlet

    package javax.servlet.http;
    
    import ....;
    
    /**
     *
     * Provides an abstract class to be subclassed to create
     * an HTTP servlet suitable for a Web site. A subclass of
     * <code>HttpServlet</code> must override at least 
     * one method, usually one of these:
     *
     * <ul>
     * <li> <code>doGet</code>, if the servlet supports HTTP GET requests
     * <li> <code>doPost</code>, for HTTP POST requests
     * <li> <code>doPut</code>, for HTTP PUT requests
     * <li> <code>doDelete</code>, for HTTP DELETE requests
     * <li> <code>init</code> and <code>destroy</code>, 
     * to manage resources that are held for the life of the servlet
     * <li> <code>getServletInfo</code>, which the servlet uses to
     * provide information about itself 
     * </ul>
     *
     * <p>There's almost no reason to override the <code>service</code>
     * method. <code>service</code> handles standard HTTP
     * requests by dispatching them to the handler methods
     * for each HTTP request type (the <code>do</code><i>XXX</i>
     * methods listed above).
     *
     * <p>Likewise, there's almost no reason to override the 
     * <code>doOptions</code> and <code>doTrace</code> methods.
     * 
     * <p>Servlets typically run on multithreaded servers,
     * so be aware that a servlet must handle concurrent
     * requests and be careful to synchronize access to shared resources.
     * Shared resources include in-memory data such as
     * instance or class variables and external objects
     * such as files, database connections, and network 
     * connections.
     * See the
     * <a href="http://java.sun.com/Series/Tutorial/java/threads/multithreaded.html">
     * Java Tutorial on Multithreaded Programming</a> for more
     * information on handling multiple threads in a Java program.
     *
     * @author	Various
     * @version	$Version$
     *
     */
    public abstract class HttpServlet extends GenericServlet
        implements java.io.Serializable
    {
        private static final String METHOD_DELETE = "DELETE";
        private static final String METHOD_HEAD = "HEAD";
        private static final String METHOD_GET = "GET";
        private static final String METHOD_OPTIONS = "OPTIONS";
        private static final String METHOD_POST = "POST";
        private static final String METHOD_PUT = "PUT";
        private static final String METHOD_TRACE = "TRACE";
    
        private static final String HEADER_IFMODSINCE = "If-Modified-Since";
        private static final String HEADER_LASTMOD = "Last-Modified";
        
        /**
        * Resource bundles contain locale-specific objects.
        */
        private static final String LSTRING_FILE =
    	"javax.servlet.http.LocalStrings";
        private static ResourceBundle lStrings =
    	ResourceBundle.getBundle(LSTRING_FILE);
    
        public HttpServlet() { }
        
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
    	throws ServletException, IOException{
            String protocol = req.getProtocol();
            String msg = lStrings.getString("http.method_get_not_supported");
            if (protocol.endsWith("1.1")) {
                resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);
            } else {
                resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);
            }
        }
    
        protected long getLastModified(HttpServletRequest req) {
    		return -1;
        }
    
        protected void doHead(HttpServletRequest req, HttpServletResponse resp)
    	throws ServletException, IOException{
            NoBodyResponse response = new NoBodyResponse(resp);
    
            doGet(req, response);
            response.setContentLength();
        }
      
        protected void doPost(HttpServletRequest req, HttpServletResponse resp)
    	throws ServletException, IOException{
            String protocol = req.getProtocol();
            String msg = lStrings.getString("http.method_post_not_supported");
            if (protocol.endsWith("1.1")) {
                resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);
            } else {
                resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);
            }
        }
      
        protected void doPut(HttpServletRequest req, HttpServletResponse resp)
    	throws ServletException, IOException{
           //ç•¥,ç±»ä¼¼doPost
        }
        
        protected void doDelete(HttpServletRequest req,
    			    HttpServletResponse resp)
    	throws ServletException, IOException{
           //ç•¥,ç±»ä¼¼doPost
        }
      
        protected void doOptions(HttpServletRequest req, HttpServletResponse resp)
    	throws ServletException, IOException{
          //ç•¥,ä¸»è¦ç”¨äºè°ƒè¯•,è¾“å‡ºå…è®¸ç±»å‹
        }
    
        protected void service(HttpServletRequest req, HttpServletResponse resp)
    	throws ServletException, IOException{
            String method = req.getMethod();
    
            if (method.equals(METHOD_GET)) {
                long lastModified = getLastModified(req);
                if (lastModified == -1) {
                // servlet doesn't support if-modified-since, no reason
                // to go through further expensive logic
                doGet(req, resp);
                } else {
                long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);
                if (ifModifiedSince < (lastModified / 1000 * 1000)) {
                    // If the servlet mod time is later, call doGet()
                            // Round down to the nearest second for a proper compare
                            // A ifModifiedSince of -1 will always be less
                    maybeSetLastModified(resp, lastModified);
                    doGet(req, resp);
                } else {
                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
                }
                }
    
            } else if (method.equals(METHOD_HEAD)) {
                long lastModified = getLastModified(req);
                maybeSetLastModified(resp, lastModified);
                doHead(req, resp);
    
            } else if (method.equals(METHOD_POST)) {
                doPost(req, resp);
    
            } else if (method.equals(METHOD_PUT)) {
                doPut(req, resp);	
    
            } else if (method.equals(METHOD_DELETE)) {
                doDelete(req, resp);
    
            } else if (method.equals(METHOD_OPTIONS)) {
                doOptions(req,resp);
    
            } else if (method.equals(METHOD_TRACE)) {
                doTrace(req,resp);
    
            } else {
                //
                // Note that this means NO servlet supports whatever
                // method was requested, anywhere on this server.
                //
    
                String errMsg = lStrings.getString("http.method_not_implemented");
                Object[] errArgs = new Object[1];
                errArgs[0] = method;
                errMsg = MessageFormat.format(errMsg, errArgs);
    
                resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);
            }
        }
    
        public void service(ServletRequest req, ServletResponse res)
    	throws ServletException, IOException{
            HttpServletRequest	request;
            HttpServletResponse	response;
    
            try {
                request = (HttpServletRequest) req;
                response = (HttpServletResponse) res;
            } catch (ClassCastException e) {
                throw new ServletException("non-HTTP request or response");
            }
            service(request, response);
        }
    }
    
    /*
     * A response that includes no body, for use in (dumb) "HEAD" support.
     * This just swallows that body, counting the bytes in order to set
     * the content length appropriately.  All other methods delegate directly
     * to the HTTP Servlet Response object used to construct this one.
     */
    // file private
    class NoBodyResponse extends HttpServletResponseWrapper {
        private NoBodyOutputStream		noBody;
        private PrintWriter			writer;
        private boolean			didSetContentLength;
    
        // file private
        NoBodyResponse(HttpServletResponse r) {
            super(r);
    	noBody = new NoBodyOutputStream();
        }
    	// ....
    }
    
    /*
     * Servlet output stream that gobbles up all its data.
     */
     
    // file private
    class NoBodyOutputStream extends ServletOutputStream {
    	//...
    }
    

    doXXX éƒ½æ˜¯æ¨¡æ¿æ–¹æ³•ï¼Œå¦‚æœå­ç±»æ²¡æœ‰å®ç°å°†æŠ›å‡ºå¼‚å¸¸
    
    doGet æ–¹æ³•å‰è¿˜ä¼šå¯¹æ˜¯å¦è¿‡æœŸåšæ£€æŸ¥ï¼Œå¦‚æœæ²¡æœ‰è¿‡æœŸï¼Œåˆ™ç›´æ¥è¿”å›304çŠ¶æ€ç åšç¼“å­˜ã€‚
    
    doHeadè°ƒç”¨äº†doGetçš„è¯·æ±‚ï¼Œç„¶åè¿”å›ç©ºbodyçš„response
    
    doOptionså’ŒdoTrace ä¸»è¦æ˜¯ç”¨æ¥åšä¸€äº›è°ƒè¯•å·¥ä½œ 

3 servletå®¹å™¨ tomcat



3.1 Tomcatçš„é¡¶å±‚ç»“æ„

    Catalina ç®¡ç†æ•´ä¸ªTomcatçš„ç®¡ç†ç±»
    
    Server æœ€é¡¶å±‚å®¹å™¨ï¼Œä»£è¡¨æ•´ä¸ªæœåŠ¡å™¨
    
    	Service æä¾›å…·ä½“æœåŠ¡ ï¼ˆå¤šä¸ªï¼‰
    
    		Connector è´Ÿè´£ç½‘ç»œè¿æ¥ã€request/responseçš„åˆ›å»ºï¼ˆå¯ä»¥æœ‰å¤šä¸ªè¿æ¥ï¼Œä»servet.xmlçš„é…ç½®ä¹Ÿå¯ä»¥çœ‹å‡ºï¼ŒåŒæ—¶æä¾›httpå’Œhttpsï¼Œä¹Ÿå¯ä»¥æä¾›ç›¸åŒåè®®ä¸åŒç«¯å£çš„è¿æ¥ï¼‰
    
    		Container å…·ä½“å¤„ç†Servlet



3.2 Bootstrap

    `org.apache.catalina.startup.Bootstrap` æ˜¯Tomcatçš„å…¥å£ï¼Œä½œç”¨ç±»ä¼¼ä¸€ä¸ª`CatalinaAdptor`ï¼Œå…·ä½“å¤„ç†è¿˜æ˜¯Catalinaæ¥å®Œæˆï¼Œè¿™æ ·åšçš„å¥½å¤„æ˜¯å¯ä»¥æŠŠå¯åŠ¨çš„å…¥å£å’Œå…·ä½“çš„ç®¡ç†ç±»åˆ†å¼€ï¼Œä»è€Œå¯ä»¥å¾ˆæ–¹ä¾¿åœ°åˆ›å»ºå‡ºå¤šç§å¯åŠ¨æ–¹å¼ã€‚ 

BootStrapä¸åœ¨Tomcatä¾èµ–åŒ…ä¸‹ ï¼Œè€Œæ˜¯åœ¨binç›®å½• é€šè¿‡åå°„ å®Œå…¨æ¾è€¦åˆ

    package org.apache.catalina.startup;
    
    import ...;
    
    public final class Bootstrap {
    
        private static final Log log = LogFactory.getLog(Bootstrap.class);
    
        /**
         * Daemon object used by main.
         */
        private static Bootstrap daemon = null;
        /**
         * Daemon reference.
         */
        private Object catalinaDaemon = null;
    
        ClassLoader commonLoader = null;
        ClassLoader catalinaLoader = null;
        ClassLoader sharedLoader = null;
    
    
        private void initClassLoaders() {
            try {
                commonLoader = createClassLoader("common", null);
                if( commonLoader == null ) {
                    // no config file, default to this loader - we might be in a 'single' env.
                    commonLoader=this.getClass().getClassLoader();
                }
                catalinaLoader = createClassLoader("server", commonLoader);
                sharedLoader = createClassLoader("shared", commonLoader);
            } catch (Throwable t) {
                handleThrowable(t);
                log.error("Class loader creation threw exception", t);
                System.exit(1);
            }
        }
    
        private ClassLoader createClassLoader(String name, ClassLoader parent)
            throws Exception {
    
            String value = CatalinaProperties.getProperty(name + ".loader");
            if ((value == null) || (value.equals("")))
                return parent;
    
            value = replace(value);
    
            List<Repository> repositories = new ArrayList<>();
    
            String[] repositoryPaths = getPaths(value);
    
            for (String repository : repositoryPaths) {
                // Check for a JAR URL repository
                try {
                    @SuppressWarnings("unused")
                    URL url = new URL(repository);
                    repositories.add(
                            new Repository(repository, RepositoryType.URL));
                    continue;
                } catch (MalformedURLException e) {
                    // Ignore
                }
    
                // Local repository
                if (repository.endsWith("*.jar")) {
                    repository = repository.substring
                        (0, repository.length() - "*.jar".length());
                    repositories.add(
                            new Repository(repository, RepositoryType.GLOB));
                } else if (repository.endsWith(".jar")) {
                    repositories.add(
                            new Repository(repository, RepositoryType.JAR));
                } else {
                    repositories.add(
                            new Repository(repository, RepositoryType.DIR));
                }
            }
    
            return ClassLoaderFactory.createClassLoader(repositories, parent);
        }
    
        /**
         * Initialize daemon.
         * @throws Exception Fatal initialization error
         */
        public void init() throws Exception {
    
            initClassLoaders();
    
            Thread.currentThread().setContextClassLoader(catalinaLoader);
    
            SecurityClassLoad.securityClassLoad(catalinaLoader);
    
            // Load our startup class and call its process() method
            if (log.isDebugEnabled())
                log.debug("Loading startup class");
            Class<?> startupClass =
                catalinaLoader.loadClass
                ("org.apache.catalina.startup.Catalina");
            Object startupInstance = startupClass.newInstance();
    
            // Set the shared extensions class loader
            if (log.isDebugEnabled())
                log.debug("Setting startup class properties");
            String methodName = "setParentClassLoader";
            Class<?> paramTypes[] = new Class[1];
            paramTypes[0] = Class.forName("java.lang.ClassLoader");
            Object paramValues[] = new Object[1];
            paramValues[0] = sharedLoader;
            Method method =
                startupInstance.getClass().getMethod(methodName, paramTypes);
            method.invoke(startupInstance, paramValues);
    
            catalinaDaemon = startupInstance;
    
        }
        
        /**
         * Load daemon.
         */
        private void load(String[] arguments)
            throws Exception {
    
            // Call the load() method
            String methodName = "load";
            Object param[];
            Class<?> paramTypes[];
            if (arguments==null || arguments.length==0) {
                paramTypes = null;
                param = null;
            } else {
                paramTypes = new Class[1];
                paramTypes[0] = arguments.getClass();
                param = new Object[1];
                param[0] = arguments;
            }
            Method method =
                catalinaDaemon.getClass().getMethod(methodName, paramTypes);
            if (log.isDebugEnabled())
                log.debug("Calling startup class " + method);
            method.invoke(catalinaDaemon, param);
        }
    
        // ----------------------------------------------------------- Main Program
    
        /**
         * Load the Catalina daemon.
         * @param arguments Initialization arguments
         * @throws Exception Fatal initialization error
         */
        public void init(String[] arguments)
            throws Exception {
            init();
            load(arguments);
    
        }
        
        /**
         * Start the Catalina daemon.
         * @throws Exception Fatal start error
         */
        public void start()
            throws Exception {
            if( catalinaDaemon==null ) init();
    
            Method method = catalinaDaemon.getClass().getMethod("start", (Class [] )null);
            method.invoke(catalinaDaemon, (Object [])null);
        }
    
        /**
         * Stop the Catalina Daemon.
         * @throws Exception Fatal stop error
         */
        public void stop()
            throws Exception {
    		//å®ç°ç•¥,ä¸»è¦é€šè¿‡åå°„è°ƒç”¨äº†catalinaçš„stop
        }
    
        /**
         * Stop the standalone server.
         * @throws Exception Fatal stop error
         */
        public void stopServer()
            throws Exception {
    		//å®ç°ç•¥,ä¸»è¦é€šè¿‡åå°„è°ƒç”¨äº†catalinaçš„stopServer
        }
        
        /**
         * Set flag.
         * @param await <code>true</code> if the daemon should block
         * @throws Exception Reflection error
         */
        public void setAwait(boolean await)
            throws Exception {
    		//å®ç°ç•¥ ,ä¸»è¦é€šè¿‡åå°„è°ƒç”¨äº†catalinaçš„setAwait
        }
    
        public boolean getAwait()
            throws Exception{
            //å®ç°ç•¥ ,ä¸»è¦é€šè¿‡åå°„è°ƒç”¨äº†catalinaçš„getAwait
        }
    
    
        /**
         * Destroy the Catalina Daemon.
         */
        public void destroy() {
            // FIXME
        }
        /**
         * Main method and entry point when starting Tomcat via the provided
         * scripts.
         *
         * @param args Command line arguments to be processed
         */
        public static void main(String args[]) {
    
            if (daemon == null) {
                // Don't set daemon until init() has completed
                Bootstrap bootstrap = new Bootstrap();
                try {
                    bootstrap.init();
                } catch (Throwable t) {
                    handleThrowable(t);
                    t.printStackTrace();
                    return;
                }
                daemon = bootstrap;
            } else {
                // When running as a service the call to stop will be on a new
                // thread so make sure the correct class loader is used to prevent
                // a range of class not found exceptions.
                Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
            }
    
            try {
                String command = "start";
                if (args.length > 0) {
                    command = args[args.length - 1];
                }
    
                if (command.equals("startd")) {
                    args[args.length - 1] = "start";
                    daemon.load(args);
                    daemon.start();
                } else if (command.equals("stopd")) {
                    args[args.length - 1] = "stop";
                    daemon.stop();
                } else if (command.equals("start")) {
                    daemon.setAwait(true);
                    daemon.load(args);
                    daemon.start();
                } else if (command.equals("stop")) {
                    daemon.stopServer(args);
                } else if (command.equals("configtest")) {
                    daemon.load(args);
                    if (null==daemon.getServer()) {
                        System.exit(1);
                    }
                    System.exit(0);
                } else {
                    log.warn("Bootstrap: command \"" + command + "\" does not exist.");
                }
            } catch (Throwable t) {
                // Unwrap the Exception for clearer error reporting
                if (t instanceof InvocationTargetException &&
                        t.getCause() != null) {
                    t = t.getCause();
                }
                handleThrowable(t);
                t.printStackTrace();
                System.exit(1);
            }
    
        }
    }

    Tomcat å¯åŠ¨è„šæœ¬ startup.bat æ˜¯ä»mainæ–¹æ³•ä¸­å¼€å§‹çš„ã€‚å…¶ä¸­ä¸»è¦åšäº†:

- å‡†å¤‡å®¹å™¨ç¯å¢ƒï¼Œinit()åˆå§‹åŒ–ç±»åŠ è½½å™¨, 
- åˆå§‹åŒ–å®¹å™¨ï¼Œè°ƒç”¨load() å®é™…æ˜¯è°ƒç”¨catalinaé‡Œçš„init()
- å¯åŠ¨å®¹å™¨ï¼Œé€šè¿‡å¼•ç”¨catalinaDaemon åå°„å°„è°ƒç”¨start()æ–¹æ³•ï¼ˆå®é™…è¿˜æ˜¯é€šè¿‡catalinaæ“ä½œå®¹å™¨ï¼‰
     å…³äºç±»åŠ è½½ï¼Œæˆ‘ä»¬éƒ½çŸ¥é“ JSEE é»˜è®¤çš„ç±»åŠ è½½æœºåˆ¶æ˜¯åŒäº²å§”æ´¾åŸåˆ™ï¼ˆè¯¦ç»†æŸ¥çœ‹å¦‚ä¸‹ğŸ”https://www.cnblogs.com/miduos/p/9250565.htmlï¼‰
  é€šè¿‡debugå¯ä»¥å‘ç°  commonLoaderã€catalinaLoader ã€sharedLoader å…¶å®ä¸‰ä¸ªæ˜¯åŒä¸€ä¸ªï¼ŒåŸå› æ˜¯å› ä¸ºcatalina.properties çš„é…ç½®ä¸­é»˜è®¤æ˜¯ç©ºçš„ã€‚
  å¦å¤–åœ¨init() ä¸­ Thread.currentThread().setContextClassLoader(catalinaLoader); 



3.3 Catalinaçš„å¯åŠ¨è¿‡ç¨‹

    Catalinaçš„å¯åŠ¨ä¸»è¦æ˜¯è°ƒç”¨`setAwait()`ã€`load()`å’Œ`start()`æ–¹æ³•æ¥å®Œæˆã€‚

- setAwait() æ–¹æ³•ç”¨äºè®¾ç½®Serverå¯åŠ¨å®Œæˆåæ˜¯å¦è¿›å…¥ç­‰å¾…çŠ¶æ€çš„æ ‡è®°
- load()æ–¹æ³•ä¸»è¦æ˜¯ç”¨æ¥åŠ è½½é…ç½®æ–‡ä»¶conf/server.xmlåˆ›å»ºServerå¯¹è±¡ ï¼ˆè§£ææ˜¯é€šè¿‡Digesterï¼‰ï¼Œç„¶åè°ƒç”¨Serverçš„init()
- start() ä¸»è¦æ˜¯è°ƒç”¨Serverçš„ start()



3.4 Serverçš„å¯åŠ¨è¿‡ç¨‹	

    Serverçš„é»˜è®¤å®ç°`org.apache.catalina.core.StandardServer` ,åœ¨å…¶çˆ¶ç±»ä¸­`org.apache.catalina.util.LifecycleBase` ä¸­çš„`init() ` å®ç°å¦‚ä¸‹

    @Override
    public final synchronized void init() throws LifecycleException {
        if (!state.equals(LifecycleState.NEW)) {
            invalidTransition(Lifecycle.BEFORE_INIT_EVENT);
        }
    
        try {
            setStateInternal(LifecycleState.INITIALIZING, null, false);
            initInternal();
            setStateInternal(LifecycleState.INITIALIZED, null, false);
        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            setStateInternal(LifecycleState.FAILED, null, false);
            throw new LifecycleException(
                    sm.getString("lifecycleBase.initFail",toString()), t);
        }
    }

 start() å®ç°å¦‚ä¸‹

    /**
     * {@inheritDoc}
     */
    @Override
    public final synchronized void start() throws LifecycleException {
    
        if (LifecycleState.STARTING_PREP.equals(state) || LifecycleState.STARTING.equals(state) ||
                LifecycleState.STARTED.equals(state)) {
    
            if (log.isDebugEnabled()) {
                Exception e = new LifecycleException();
                log.debug(sm.getString("lifecycleBase.alreadyStarted", toString()), e);
            } else if (log.isInfoEnabled()) {
                log.info(sm.getString("lifecycleBase.alreadyStarted", toString()));

EJB

JMS


            }
    
            return;
        }
    
        if (state.equals(LifecycleState.NEW)) {
            init();
        } else if (state.equals(LifecycleState.FAILED)) {
            stop();
        } else if (!state.equals(LifecycleState.INITIALIZED) &&
                !state.equals(LifecycleState.STOPPED)) {
            invalidTransition(Lifecycle.BEFORE_START_EVENT);
        }
    
        try {
            setStateInternal(LifecycleState.STARTING_PREP, null, false);
            startInternal();
            if (state.equals(LifecycleState.FAILED)) {
                // This is a 'controlled' failure. The component put itself into the
                // FAILED state so call stop() to complete the clean-up.
                stop();
            } else if (!state.equals(LifecycleState.STARTING)) {
                // Shouldn't be necessary but acts as a check that sub-classes are
                // doing what they are supposed to.
                invalidTransition(Lifecycle.AFTER_START_EVENT);
            } else {
                setStateInternal(LifecycleState.STARTED, null, false);
            }
        } catch (Throwable t) {
            // This is an 'uncontrolled' failure so put the component into the
            // FAILED state and throw an exception.
            ExceptionUtils.handleThrowable(t);
            setStateInternal(LifecycleState.FAILED, null, false);
            throw new LifecycleException(sm.getString("lifecycleBase.startFail", toString()), t);
        }
    }

    å…¶ä¸­ `startInternal() å’Œ initInternal()` ä¸ºæ¨¡ç‰ˆæ–¹æ³• ï¼ŒæŸ¥çœ‹å…¶å®ç°ç±» å¯ä»¥å‘ç°æ˜¯å¾ªç¯è°ƒç”¨äº†æ¯ä¸ª`service`çš„`start()`å’Œ`init()`

3.5 Serviceçš„å¯åŠ¨è¿‡ç¨‹

    	ç±»ä¼¼äºServer , `StandardService`çš„`initInternal()`å’Œ `startInternal()`çš„æ–¹æ³•ä¸»è¦è°ƒç”¨`container`ã€`executors`ã€`mapperListener`ã€`connectors`çš„`init()`å’Œ`start()`æ–¹æ³•ã€‚







4  servletæ ‡å‡†å®ç° springmvc dispatcherServlet

